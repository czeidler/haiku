/*
 * Copyright (c) 2005 Palmsource, Inc.
 * 
 * This software is licensed as described in the file LICENSE, which
 * you should have received as part of this distribution. The terms
 * are also available at http://www.openbinder.org/license.html.
 * 
 * This software consists of voluntary contributions made by many
 * individuals. For the exact contribution history, see the revision
 * history and logs, available at http://www.openbinder.org
 */

#include "PaladinBackend.h"

#include "CPPOutputUtil.h"
#include "OutputI.h"
#include "OutputUtil.h"
#include "TypeBank.h"

#include <ctype.h>


extern sptr<IDLType> FindType(const sptr<IDLType>& typeptr);	// in main.cpp

#if _SUPPORTS_NAMESPACE
using namespace palmos::support;
#endif


bool
PaladinBackend::_WriteHeader(sptr<ITextOutput> stream,
	SVector<InterfaceRec *> &recs, const SString &filename,
	SVector<IncludeRec> & headers, IDLStruct& result)
{
	const sptr<IDLCommentBlock>& beginComments = result.BeginComments();
	const sptr<IDLCommentBlock>& endComments = result.EndComments();

	NamespaceGenerator nsGen;
	SString headerGuard;
	status_t err = HeaderGuard(filename, headerGuard, false);

	if (err != B_OK) return err;
	stream << "/*========================================================== */ " << endl;
	stream << "// header file automatically generated by PIDGEN - DO NOT MODIFY" << endl;
	stream << "/*========================================================== */ " << endl << endl;

	stream << "#ifndef " << headerGuard << endl;
	stream << "#define " << headerGuard << endl;
	stream << endl;

	stream << "#include <vector>" << endl;

	stream << "#include <PObject.h>" << endl;
	stream << endl;

	size_t count = headers.CountItems();
	for (size_t i=0; i<count; i++) {
		//bout << "// header comments: " << headers[i].Comments() << endl;
		if (headers[i].Comments() != NULL)
			headers[i].Comments()->Output(stream, false);
		stream << "#include " << "<" << headers[i].File() << ">" << endl;
	}
	if (count > 0) stream << endl;
	

	//bout << "// begin comments: " << beginComments << endl;
	if (beginComments != NULL) {
		beginComments->Output(stream, false);
		stream << endl;
	}

	// Write all forward declarations
	bool didHeader = false;
	size_t recordCount = recs.CountItems();
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
		SString noid=rec->ID();
		if (rec->Declaration()==FWD) {
			if (!didHeader) {
				stream << "/* ============= Forward Declarations =========================== */" << endl;
				stream << endl;
				didHeader = true;
			}
			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());
			stream << "class " << rec->ID() << ";" << endl;
	  }
	}
	if (didHeader) {
		stream << endl;
	}

	// Write class definitions
	stream << "/* ============= Interface Class Declarations =========================== */" << endl;
	stream << endl;
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
		SString noid=rec->ID();
		noid.RemoveFirst("I");
		if (rec->Declaration()==DCL) {
			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());
			rec->OutputComment(stream, false);
			SVector<SString> parents = rec->Parents();
			if (parents.CountItems() == 0) {
				stream << "class " << rec->ID() << " : public PObject" << endl;
			} 
			else {
				stream << "class " << rec->ID() << " : ";
				for (size_t i_parent = 0; i_parent < parents.CountItems(); i_parent++) {
					if (i_parent > 0) {
						stream << ", ";
					}
					stream << "public " << parents[i_parent];
				}
				stream << endl;
			}
			stream << "{" << endl;

			// Write Class body...
			uint32 typedefCount = rec->CountTypedefs();
			uint32 propertyCount = rec->CountProperties();
			uint32 methodCount = rec->CountMethods();
			uint32 eventCount = rec->CountEvents();
			uint32 constructCount = rec->CountConstructs();

			stream << "public:" << endl;
			stream << indent;
			stream << endl << endl;

			// print all typedefs
			if (typedefCount != 0) {
				stream << endl;
				stream << "/* ------- Typedefs --------------------- */" << endl;
			}
			for (uint32 i_typedef = 0; i_typedef < typedefCount; i_typedef++) {
				sptr<IDLNameType> def = rec->TypedefAt(i_typedef);
				stream << dedent;
				def->OutputComment(stream);
				stream << indent;
				stream << "typedef ";
				// get the base type for this typedef and convert that
				sptr<IDLType> baseType = FindType(def->m_type);
				SString cppType = TypeToCPPType(kInsideClassScope, baseType, false);
				if (baseType->GetCode() == B_VARIABLE_ARRAY_TYPE) {
					stream << "SVector<" << cppType;
					if (cppType.FindFirst('>') > 0) {
						// leave extra space when we are dealing with 
						// a template type
						stream << " ";
					}
					stream << ">";
				}
				else {
					stream << cppType;
				}
				stream << " " << def->m_id << ";" << endl;
			}

			// take care of any enums/structs we have
			// They are packaged as IDLMethods, with each member being a parameter
			if (constructCount > 0) {
				stream << endl;
				stream << "/* ------- enums/structs --------------------- */" << endl;
			}
			for (size_t i_enum = 0; i_enum < constructCount; i_enum++) {
				sptr<IDLConstruct> construct = rec->ConstructAt(i_enum);
				stream << dedent;
				construct->OutputComment(stream);	
				stream << indent;
				SString constructName = construct->ID();
				bool inStruct = (constructName.FindLast("struct") >= 0);
				stream << constructName << " {" << endl << indent;

				uint32 memberCount = construct->CountParams();
				for (uint32 i_member = 0; i_member < memberCount; i_member++) {
					sptr<IDLNameType> member = construct->ParamAt(i_member);
					// first write the comment (if it exists, it will end with newline)
					member->OutputComment(stream);
					// then write the actual member
					stream << member->m_id;
					// terminate the member/enumerator 
					if (inStruct == true) {
						stream << ";";
					}
					else if (i_member < memberCount-1) {
						stream << ",";
					}
					stream << endl;
				}
				construct->OutputTrailingComment(stream);
				stream << dedent << "};" << endl << endl;
			}

			// interface stuff
			stream << "void				InterfaceList(std::vector<BString>& list);" << endl;
			
			
			if (propertyCount != 0) {
				stream << endl;
				stream << "/* ------- Properties --------------------- */" << endl;
			}
			for (uint32 i_prop = 0; i_prop < propertyCount; i_prop++) {
				sptr<IDLNameType> nt = rec->PropertyAt(i_prop);
				stream << endl;
				WritePropertyDeclarations(stream, nt, true);
			}
			
			if (methodCount != 0) {
				stream << endl;
				stream << "// ------- Methods ------------------------" << endl;
			}
			for (uint32 i_method = 0; i_method < methodCount; i_method++) {
				sptr<IDLMethod> method = rec->MethodAt(i_method);
				stream << endl;
				WriteMethodDeclaration(stream, method, true);
			}

			if (eventCount != 0) {
				stream << endl;
				stream << "// ------- Events ------------------------" << endl;
			}
			SString localClass = noid;
			localClass.RemoveFirst("I");

			for (uint32 i_event = 0; i_event < eventCount; i_event++) {
				sptr<IDLEvent> event = rec->EventAt(i_event);
				stream << endl;
				// For each event, just right a doxygen comment refering them
				// to the event methods in the BnClass
				stream << "/*! \\fn void " << event->ID() << "()" << endl;
				stream << "\t\\brief An event implemented by Push" << event->ID() << endl;
				stream << "\t\\see " << gNativePrefix << localClass << "::Push" << event->ID() << " */" << endl;
			}

			/* ------- protected default ctor/dtor ------------------------- */
			/* ------- private copy constructor and assignment operator ------------------------- */
			stream << dedent;
			stream << endl << "protected:" << endl;
			stream << indent;
			SString className = rec->ID();
			stream << "\t\t" << PadString(SString(""), TYPE_TABS) << className << "();" << endl;
			stream << "virtual\t" << PadString(SString(""), TYPE_TABS) << "~" << className << "();" << endl;

			stream << dedent;
			stream << endl << "private:" << endl;
			stream << indent;
			/*stream << "// ------- copy/assignment protection ------------------" << endl;
			// SString className = rec->ID();
			stream << "\t\t" << PadString(SString(""), TYPE_TABS)
					<< className << "(const " << className << "& o);" << endl;
			SString classReference(className);
			classReference.Append("*");
			stream << "\t\t" << classReference << PadString(classReference, TYPE_TABS)
					<< "operator=(const " << className << "* o);" << endl;
			*/
			stream << dedent;
			stream << "};" << endl;
			stream << endl;
		}
	}

	nsGen.CloseNamespace(stream);

	//bout << "// end comments: " << endComments << endl;
	if (endComments != NULL) {
		stream << endl;
		endComments->Output(stream, false);
	}

	stream << endl;
	stream << "#endif // " << headerGuard << endl;
	stream << endl;
	
	return true;
}


static void
WriteFunctionPrototype(sptr<ITextOutput> stream, InterfaceRec* base,
	sptr<IDLMethod> method, SString className)
{
	stream << endl;
	sptr<IDLType> returnType = method->ReturnType();

	SString type = TypeToCPPType(base, returnType, false);
	stream << "" << type << endl;
	stream << className << "::" << method->ID() << "(";
	
	int paramCount = method->CountParams();
	for (int32_t i_param = 0; i_param < paramCount; i_param++) {
		sptr<IDLNameType> nt = method->ParamAt(i_param);
		uint32_t direction = nt->m_type->GetDirection();

		if ((direction == kOut) || (direction == kInOut)) {	
			type = TypeToCPPType(kInsideClassScope, nt->m_type, false); 
			stream << type << "* " << nt->m_id;	
		}
		else { 
			type = TypeToCPPType(kInsideClassScope, nt->m_type, true); 
			stream << type << " " << nt->m_id;
		}
		
		if (i_param != paramCount-1) {
			stream << ", ";
		}
	}
	
	if (method->IsConst()) {
		stream << ") const " << endl;
	}
	else {
		stream << ")" << endl;
	}
}


static status_t
WritePaladinMethods(sptr<ITextOutput> stream,
	SVector<InterfaceRec*>& allInterfaces, InterfaceRec* rec,
	SString noid)
{
	const size_t recordCount = allInterfaces.CountItems();
	SString class_name;
	class_name += noid;

	stream << "void" << endl;
	stream << class_name << "::InterfaceList(std::vector<BString>& list)"
		<< endl << "{" << endl << indent;
	for (size_t i_parent = 0; i_parent < recordCount; i_parent++) {
		stream << "list.push_back(\"" << allInterfaces[i_parent]->ID()
			<< "\");" << endl;
	}
	stream << dedent << "}" << endl;
	stream << endl << endl;

	// ------- Methods ------------------------
/*	int32_t methodCount = rec->CountMethods();
	stream << "// Methods" << endl;
	for (int32_t i_method = 0; i_method < methodCount; i_method++) {
		sptr<IDLMethod> method = rec->MethodAt(i_method);
		WriteFunctionPrototype(stream, rec, method, noid);
		stream << "{" << endl << indent;

		stream << dedent << "}" << endl;
	}
*/
	return B_OK;
}


static const char*
PaladinTypeFor(const sptr<IDLType>& type)
{
	sptr<IDLType> baseType = FindType(type);
	uint32 code = baseType->GetCode();

	switch (code) {
		case B_BOOL_TYPE:
			return "B_BOOL_TYPE";

		case B_INT8_TYPE:
		case B_UINT8_TYPE:
			return "B_INT8_TYPE";

		case B_INT16_TYPE:
		case B_UINT16_TYPE:
			return "B_INT16_TYPE";

		case B_INT32_TYPE:
		case B_UINT32_TYPE:
			return "B_INT32_TYPE";

		case B_INT64_TYPE:
		case B_UINT64_TYPE:
			return "B_INT64_TYPE";
		
		case B_FLOAT_TYPE:
			return "B_FLOAT_TYPE";

		case B_DOUBLE_TYPE:
			return "B_DOUBLE_TYPE";
		
		case B_STRING_TYPE:
			return "B_STRING_TYPE";

		case B_CHAR_TYPE:
			return "B_CHAR_TYPE";
	}

	return "B_RAW_TYPE";
}


static void
WriteCallbackMethod(sptr<ITextOutput>& stream, SString& className,
	sptr<IDLMethod>& method)
{
	SString callbackName("_");
	callbackName += className;
	callbackName += method->ID();

	stream << "static status_t" << endl;
	stream << callbackName
		<< "(void* pObject, PArgs *in, PArgs *out, void*)"
		<< endl;
	stream << "{" << endl << indent;

	stream << "if (!pObject || !in || !out)" << endl << indent
		<< "return B_ERROR;" << dedent << endl;

	stream << className << "* that = reinterpret_cast<" << className
		<< "*>(pObject);" << endl;
	stream << "if (!that)" << endl << indent
		<< "return B_BAD_TYPE;" << endl << dedent;

	int paramCount = method->CountParams();
	SString argumentString;
	SVector<SString> outTypes;
	SVector<SString> outId;
	SVector<SString> outNames;
	for (int32_t i_param = 0; i_param < paramCount; i_param++) {
		sptr<IDLNameType> nt = method->ParamAt(i_param);
		
		SString type = TypeToCPPType(kInsideClassScope, nt->m_type, false);

		SString varName("var");
		varName << i_param + 1;
		
		stream << type;
		if (nt->m_type->GetName() == "sptr")
			stream << "*";
		stream << " " << varName << ";" << endl;

		uint32_t direction = nt->m_type->GetDirection();
		if ((direction == kIn) || (direction == kInOut)) {	
			stream << "if (find_parg_" << type << "(in, \"" << nt->m_id
				<< "\", " << "&" << varName << ") != B_OK)"
				<< endl;
			stream << indent << "return B_ERROR;" << dedent << endl;
		} else if (nt->m_type->GetName() == "sptr") {
			stream << "if (find_parg_pointer(in, \"" << nt->m_id
				<< "\", " << "(void**)&" << varName << ") != B_OK)"
				<< endl;
			stream << indent << "return B_ERROR;" << dedent << endl;
		}

		if (i_param != 0)
			argumentString += ", ";
		if (direction != kIn && nt->m_type->GetName() != "sptr")
			argumentString += "&";
		argumentString += varName;

		if ((direction == kOut) || (direction == kInOut)) {
			outTypes.AddItem(type);
			outId.AddItem(nt->m_id);
			outNames.AddItem(varName);
		}
	}

	sptr<IDLType> ntType = method->ReturnType();
	SString returnType = TypeToCPPType(kInsideClassScope, ntType, false);
	if (returnType != "void")
		stream << returnType << " returnValue = ";
	stream << "that->" << method->ID() << "(" << argumentString << ");" << endl;

	if (returnType != "void") {
		for (uint32 i = 0; i < outTypes.CountItems(); i++) {
			stream << "add_parg_" << outTypes[i] << "(out, \"" << outId[i]
				<< "\", " << outNames[i] << ");" <<  endl;
		}
	}

	stream << endl << "return B_OK;" << endl;
	stream << dedent << "}" << endl;
	stream << endl << endl;
}

	
bool
PaladinBackend::_WriteCPP(sptr<ITextOutput> stream, SVector<InterfaceRec *> &recs,
	const SString & filename, const SString & lHeader)
{
	SString printablefn=filename;
	printablefn.Append(".cpp");
	printablefn.RemoveFirst(".\\");

	stream << "/*========================================================== */ " << endl;
	stream << "// "<< printablefn << " is automatically generated by PIDGEN - DO NOT MODIFY" << endl;
	stream << "/*========================================================== */ " << endl << endl;

	stream << endl;

	stream << "#include " << '\"' << lHeader << '\"' << endl;
	stream << endl;
	stream << "#include <InterfaceDefs.h>" << endl << endl;
	stream << "#include <PObject.h>" << endl << endl;

	NamespaceGenerator nsGen;
	size_t recordCount = recs.CountItems();
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
	
		SString className=rec->ID();	
		className.RemoveFirst("I");

		if (rec->Declaration()==DCL) {
			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());

			// ------ Callback Method Functions
			int32_t methodCount = rec->CountMethods();
			for (int32_t i_method = 0; i_method < methodCount; i_method++) {
				sptr<IDLMethod> method = rec->MethodAt(i_method);
				WriteCallbackMethod(stream, className, method);
			}


			// ------ Class Members
			stream << "// ------ Class Members ----------------------" << endl;
			stream << endl;

			stream << className << "::" << className << "()" << endl;
			stream << "{" << endl << indent;

			stream << "PMethodInterface pmi;" << endl;
			
			for (int32_t i_method = 0; i_method < methodCount; i_method++) {
				sptr<IDLMethod> method = rec->MethodAt(i_method);
				SString callbackName("_");
				callbackName += className;
				callbackName += method->ID();

				stream << "pmi.MakeEmpty();" << endl;
				int paramCount = method->CountParams();
				for (int32_t i_param = 0; i_param < paramCount; i_param++) {
					sptr<IDLNameType> nt = method->ParamAt(i_param);
					if (nt->m_type->GetDirection() == kOut)
						continue;	
					stream << "pmi.AddArg(\"" << nt->m_id << "\", "
						<< PaladinTypeFor(nt->m_type) << ", \"\");" << endl;
				}
				stream << "AddMethod(new PMethod(\"" << method->ID()
					<< "\", " << callbackName << ", &pmi));" << endl << endl;
			}
			stream << dedent << "}" << endl;
			stream << endl;
			stream << endl;

			// ------- Methods

			// Currently our only class member is an empty destructor.
			// But this is needed for the vtable copy needed for RVDS, and C++ library support
			stream << rec->ID() << "::~" << rec->ID() << "()" << endl;
			stream << "{" << endl;
			stream << "}" << endl << endl;

			stream << endl;
			stream << endl;

			SVector<InterfaceRec*> allInterfaces;
			CollectParents(rec, recs, &allInterfaces);

			WritePaladinMethods(stream, allInterfaces, rec, className);
		}

	}

	nsGen.CloseNamespace(stream);

	return false;
}
