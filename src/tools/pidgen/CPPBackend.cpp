/*
 * Copyright (c) 2005 Palmsource, Inc.
 * 
 * This software is licensed as described in the file LICENSE, which
 * you should have received as part of this distribution. The terms
 * are also available at http://www.openbinder.org/license.html.
 * 
 * This software consists of voluntary contributions made by many
 * individuals. For the exact contribution history, see the revision
 * history and logs, available at http://www.openbinder.org
 */

#include "CPPBackend.h"

#include "CPPOutputUtil.h"
#include "OutputI.h"
#include "OutputUtil.h"
#include "TypeBank.h"

#include <ctype.h>


extern sptr<IDLType> FindType(const sptr<IDLType>& typeptr);	// in main.cpp

#if _SUPPORTS_NAMESPACE
using namespace palmos::support;
#endif


bool
CPPBackend::_WriteHeader(sptr<ITextOutput> stream,
	SVector<InterfaceRec *> &recs, const SString &filename,
	SVector<IncludeRec> & headers, IDLStruct& result)
{
	const sptr<IDLCommentBlock>& beginComments = result.BeginComments();
	const sptr<IDLCommentBlock>& endComments = result.EndComments();

	NamespaceGenerator nsGen;
	SString headerGuard;
	status_t err = HeaderGuard(filename, headerGuard, false);

	if (err != B_OK) return err;
	stream << "/*========================================================== */ " << endl;
	stream << "// header file automatically generated by PIDGEN - DO NOT MODIFY" << endl;
	stream << "/*========================================================== */ " << endl << endl;

	stream << "#ifndef " << headerGuard << endl;
	stream << "#define " << headerGuard << endl;
	stream << endl;

	//stream << "#include <PObject.h>" << endl;
	stream << endl;

	size_t count = headers.CountItems();
	for (size_t i=0; i<count; i++) {
		//bout << "// header comments: " << headers[i].Comments() << endl;
		if (headers[i].Comments() != NULL)
			headers[i].Comments()->Output(stream, false);
		stream << "#include " << "<" << headers[i].File() << ">" << endl;
	}
	if (count > 0) stream << endl;
	

	//bout << "// begin comments: " << beginComments << endl;
	if (beginComments != NULL) {
		beginComments->Output(stream, false);
		stream << endl;
	}

	// Write all forward declarations
	bool didHeader = false;
	size_t recordCount = recs.CountItems();
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
		SString noid=rec->ID();
		if (rec->Declaration()==FWD) {
			if (!didHeader) {
				stream << "/* ============= Forward Declarations =========================== */" << endl;
				stream << endl;
				didHeader = true;
			}
			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());
			stream << "class " << rec->ID() << ";" << endl;
	  }
	}
	if (didHeader) {
		stream << endl;
	}

	// Write class definitions
	stream << "/* ============= Interface Class Declarations =========================== */" << endl;
	stream << endl;
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
		SString noid=rec->ID();
		noid.RemoveFirst("I");
		if (rec->Declaration()==DCL) {
			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());
			rec->OutputComment(stream, false);
			SVector<SString> parents = rec->Parents();
			if (parents.CountItems() == 0) {
				stream << "class " << rec->ID() << " : public IInterface" << endl;
			} 
			else {
				stream << "class " << rec->ID() << " : ";
				for (size_t i_parent = 0; i_parent < parents.CountItems(); i_parent++) {
					if (i_parent > 0) {
						stream << ", ";
					}
					stream << "public " << parents[i_parent];
				}
				stream << endl;
			}
			stream << "{" << endl;

			// Write Class body...
			uint32 typedefCount = rec->CountTypedefs();
			uint32 propertyCount = rec->CountProperties();
			uint32 methodCount = rec->CountMethods();
			uint32 eventCount = rec->CountEvents();
			uint32 constructCount = rec->CountConstructs();

			stream << "public:" << endl;
			stream << indent;
			stream << "B_DECLARE_META_INTERFACE(" << noid << ")" << endl << endl;

			// print all typedefs
			if (typedefCount != 0) {
				stream << endl;
				stream << "/* ------- Typedefs --------------------- */" << endl;
			}
			for (uint32 i_typedef = 0; i_typedef < typedefCount; i_typedef++) {
				sptr<IDLNameType> def = rec->TypedefAt(i_typedef);
				stream << dedent;
				def->OutputComment(stream);
				stream << indent;
				stream << "typedef ";
				// get the base type for this typedef and convert that
				sptr<IDLType> baseType = FindType(def->m_type);
				SString cppType = TypeToCPPType(kInsideClassScope, baseType, false);
				if (baseType->GetCode() == B_VARIABLE_ARRAY_TYPE) {
					stream << "SVector<" << cppType;
					if (cppType.FindFirst('>') > 0) {
						// leave extra space when we are dealing with 
						// a template type
						stream << " ";
					}
					stream << ">";
				}
				else {
					stream << cppType;
				}
				stream << " " << def->m_id << ";" << endl;
			}

			// take care of any enums/structs we have
			// They are packaged as IDLMethods, with each member being a parameter
			if (constructCount > 0) {
				stream << endl;
				stream << "/* ------- enums/structs --------------------- */" << endl;
			}
			for (size_t i_enum = 0; i_enum < constructCount; i_enum++) {
				sptr<IDLConstruct> construct = rec->ConstructAt(i_enum);
				stream << dedent;
				construct->OutputComment(stream);	
				stream << indent;
				SString constructName = construct->ID();
				bool inStruct = (constructName.FindLast("struct") >= 0);
				stream << constructName << " {" << endl << indent;

				uint32 memberCount = construct->CountParams();
				for (uint32 i_member = 0; i_member < memberCount; i_member++) {
					sptr<IDLNameType> member = construct->ParamAt(i_member);
					// first write the comment (if it exists, it will end with newline)
					member->OutputComment(stream);
					// then write the actual member
					stream << member->m_id;
					// terminate the member/enumerator 
					if (inStruct == true) {
						stream << ";";
					}
					else if (i_member < memberCount-1) {
						stream << ",";
					}
					stream << endl;
				}
				construct->OutputTrailingComment(stream);
				stream << dedent << "};" << endl << endl;
			}

			if (propertyCount != 0) {
				stream << endl;
				stream << "/* ------- Properties --------------------- */" << endl;
			}
			for (uint32 i_prop = 0; i_prop < propertyCount; i_prop++) {
				sptr<IDLNameType> nt = rec->PropertyAt(i_prop);
				stream << endl;
				WritePropertyDeclarations(stream, nt, true);
			}
			
			if (methodCount != 0) {
				stream << endl;
				stream << "/* ------- Methods ------------------------ */" << endl;
			}
			for (uint32 i_method = 0; i_method < methodCount; i_method++) {
				sptr<IDLMethod> method = rec->MethodAt(i_method);
				stream << endl;
				WriteMethodDeclaration(stream, method, true);
			}

			if (eventCount != 0) {
				stream << endl;
				stream << "/* ------- Events ------------------------ */" << endl;
			}
			SString localClass = noid;
			localClass.RemoveFirst("I");

			for (uint32 i_event = 0; i_event < eventCount; i_event++) {
				sptr<IDLEvent> event = rec->EventAt(i_event);
				stream << endl;
				// For each event, just right a doxygen comment refering them
				// to the event methods in the BnClass
				stream << "/*! \\fn void " << event->ID() << "()" << endl;
				stream << "\t\\brief An event implemented by Push" << event->ID() << endl;
				stream << "\t\\see " << gNativePrefix << localClass << "::Push" << event->ID() << " */" << endl;
			}

			/* ------- protected default ctor/dtor ------------------------- */
			/* ------- private copy constructor and assignment operator ------------------------- */
			stream << dedent;
			stream << endl << "protected:" << endl;
			stream << indent;
			SString className = rec->ID();
			stream << "\t\t" << PadString(SString(""), TYPE_TABS) << className << "() { }" << endl;
			stream << "virtual\t" << PadString(SString(""), TYPE_TABS) << "~" << className << "();" << endl;

			stream << dedent;
			stream << endl << "private:" << endl;
			stream << indent;
			stream << "/* ------- copy/assignment protection ------------------ */" << endl;
			// SString className = rec->ID();
			stream << "\t\t" << PadString(SString(""), TYPE_TABS)
					<< className << "(const " << className << "& o);" << endl;
			SString classReference(className);
			classReference.Append("&");
			stream << "\t\t" << classReference << PadString(classReference, TYPE_TABS)
					<< "operator=(const " << className << "& o);" << endl;

			stream << dedent;
			stream << "};" << endl;
			stream << endl;
		}
	}

	nsGen.CloseNamespace(stream);

	//bout << "// end comments: " << endComments << endl;
	if (endComments != NULL) {
		stream << endl;
		endComments->Output(stream, false);
	}

	stream << endl;
	stream << "#endif // " << headerGuard << endl;
	stream << endl;
	
	return true;
}


static status_t
WriteLocalClass(sptr<ITextOutput> stream, InterfaceRec* base,
	const SVector<InterfaceRec*>& recs, SString noid)
{
	const size_t recordCount = recs.CountItems();
	SString class_name;
		class_name += gNativePrefix;
		class_name += noid;

	stream << "/* ------ Local Class -------------------------- */" << endl << endl;
	
	stream << "SValue" << endl
		<< class_name << "::Inspect(const sptr<IBinder>& /*caller*/, const SValue &which, uint32_t)" << endl
		<< "{" << endl << indent;
	if (recordCount <= 1) {
		stream << "return which * SValue(" << recs[0]->ID() << "::Descriptor(), SValue::Binder(this));"
			<< dedent << endl << "}" << endl;
	} 
	else {
		stream << "SValue result(which * SValue(" << recs[0]->ID() << "::Descriptor(), SValue::Binder(this)));" << endl;
		for (uint32 i_record = 1; i_record < recordCount; i_record++) {
			stream << "result.Join(which * SValue(" << recs[i_record]->ID() << "::Descriptor(), SValue::Binder(this)));" << endl;
		}
		stream << "return result;" << dedent << endl << "}" << endl;
	}

	stream << endl << "sptr<IInterface>" << endl
		<< class_name << "::InterfaceFor(const SValue &desc, uint32_t flags)" << endl
		<< "{" << endl << indent;
	// Notice that in the case of multiple inheritance, that the cast here in InterfaceFor we want the
	// actual class that derives from IInterface.
	// For example, in the case of:
	//	class ICatalog : public INode, IIterable
	// The casts are as follows:
	//	desc == INode::Descriptor()) -> static_cast<INode*>(this)
	//	desc == IIterator::Descriptor() -> static_cast<IIterator*>(this)
	//	desc == ICatalog::Descriptor() -> static_cast<INode*>(this)
	// This is different than the marshalling/unmarshalling where we would always cast to INode.
	// The reason for this is that IIterable::AsInterface(this) is called, we need the IInterface
	// that corresponds to the IIterable.
	// (So we call rec->LeftMostBase() rather than base->LeftMostBase(). For IIterable this
	// would return IIterable.  In contrast, CastExpression() would always result in INode.)
	for (uint32 i_record = 0; i_record < recordCount; i_record++) {
		stream << "if (desc == " << recs[i_record]->ID() << "::Descriptor()) return sptr<IInterface>(static_cast<" << recs[i_record]->LeftMostBase() << "*>(this));" << endl;
	}
	stream << "return BBinder::InterfaceFor(desc, flags);" << dedent << endl << "}" << endl;
	stream << endl;


	stream << dedent;
	stream << "}" << endl;
	stream << endl;

	return B_OK;
}


bool
CPPBackend::_WriteCPP(sptr<ITextOutput> stream, SVector<InterfaceRec *> &recs,
	const SString & filename, const SString & lHeader)
{
	SString printablefn=filename;
	printablefn.Append(".cpp");
	printablefn.RemoveFirst(".\\");

	stream << "/*========================================================== */ " << endl;
	stream << "// "<< printablefn << " is automatically generated by PIDGEN - DO NOT MODIFY" << endl;
	stream << "/*========================================================== */ " << endl << endl;

	stream << endl;

	stream << "#include " << '\"' << lHeader << '\"' << endl;
	stream << endl;

	NamespaceGenerator nsGen;
	size_t recordCount = recs.CountItems();
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
	
		SString noid=rec->ID();	
		noid.RemoveFirst("I");

		if (rec->Declaration()==FWD) {
			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());

			stream << "/* ------ Forward Declaration ---------------------- */" << endl;
			stream << endl;

			SVector<SString> parents = rec->Parents();
			if (parents.CountItems() == 0) {
				stream << "class " << rec->ID() << " : public IInterface" << endl;
			} else {
				stream << "class " << rec->ID() << " : ";
				size_t parentCount = parents.CountItems();
				for (size_t i_parent = 0; i_parent < parentCount; i_parent++) {
					if (i_parent > 0) {
						stream << ", ";
					}
					stream << "public " << parents[i_parent];
				}
				stream << endl;
			}

			stream << "{" << endl;
			stream << "public:" << endl;
			
			stream << indent;
			
			stream << "B_DECLARE_META_INTERFACE(" << noid << ")" << endl << endl;
			stream << dedent << "};" << endl << endl;
		}	

		if (rec->Declaration()==DCL) {
			SVector<InterfaceRec*> allInterfaces;
			CollectParents(rec, recs, &allInterfaces);

			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());

			/* ------ Class Members ---------------------- */
			stream << "/* ------ Class Members ---------------------- */" << endl;
			stream << endl;
			// Currently our only class member is an empty destructor.
			// But this is needed for the vtable copy needed for RVDS, and C++ library support
			stream << rec->ID() << "::~" << rec->ID() << "()" << endl;
			stream << "{" << endl;
			stream << "}" << endl << endl;

			stream << endl;
			stream << endl;

			WriteLocalClass(stream, rec, allInterfaces, noid);

		}

	}

	nsGen.CloseNamespace(stream);

	return false;
}
