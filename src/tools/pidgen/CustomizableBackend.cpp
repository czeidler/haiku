/*
 * Copyright (c) 2005 Palmsource, Inc.
 * 
 * This software is licensed as described in the file LICENSE, which
 * you should have received as part of this distribution. The terms
 * are also available at http://www.openbinder.org/license.html.
 * 
 * This software consists of voluntary contributions made by many
 * individuals. For the exact contribution history, see the revision
 * history and logs, available at http://www.openbinder.org
 */

#include "CustomizableBackend.h"

#include "CPPOutputUtil.h"
#include "OutputI.h"
#include "OutputUtil.h"
#include "TypeBank.h"

#include <ctype.h>


extern sptr<IDLType> FindType(const sptr<IDLType>& typeptr);	// in main.cpp


static SString LocalClassName(InterfaceRec* rec)
{
	SString localClassName = rec->ID();
	return localClassName;
}


static SString IPCProxyClassName(InterfaceRec* rec)
{
	SString localClassName = rec->ID();
	localClassName.RemoveFirst("I");
	localClassName.Prepend("IPCProxy");
	return localClassName;
}


bool
CustomizableBackend::_WriteHeader(sptr<ITextOutput> stream,
	SVector<InterfaceRec *> &recs, const SString &filename,
	SVector<IncludeRec> & headers, IDLStruct& result)
{
	const sptr<IDLCommentBlock>& beginComments = result.BeginComments();
	const sptr<IDLCommentBlock>& endComments = result.EndComments();

	NamespaceGenerator nsGen;
	SString headerGuard;
	status_t err = HeaderGuard(filename, headerGuard, false);

	if (err != B_OK) return err;
	stream << "/*========================================================== */ " << endl;
	stream << "// header file automatically generated by PIDGEN - DO NOT MODIFY" << endl;
	stream << "/*========================================================== */ " << endl << endl;

	stream << "#ifndef " << headerGuard << endl;
	stream << "#define " << headerGuard << endl;
	stream << endl;

	stream << "#include <Customizable.h>" << endl;
	stream << "#include <IPCLooper.h>" << endl;
	stream << endl;

	size_t count = headers.CountItems();
	for (size_t i=0; i<count; i++) {
		//bout << "// header comments: " << headers[i].Comments() << endl;
		if (headers[i].Comments() != NULL)
			headers[i].Comments()->Output(stream, false);
		stream << "#include " << "<" << headers[i].File() << ">" << endl;
	}
	if (count > 0) stream << endl;
	
	stream << "#include \"CustomTypes.h\"" << endl << endl;

	//bout << "// begin comments: " << beginComments << endl;
	if (beginComments != NULL) {
		beginComments->Output(stream, false);
		stream << endl;
	}

	// Write all forward declarations
	bool didHeader = false;
	size_t recordCount = recs.CountItems();
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
		SString noid=rec->ID();
		if (rec->Declaration()==FWD) {
			if (!didHeader) {
				stream << "/* ============= Forward Declarations =========================== */" << endl;
				stream << endl;
				didHeader = true;
			}
			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());
			stream << "class " << rec->ID() << ";" << endl;
		}
	}
	if (didHeader) {
		stream << endl;
	}
/*
	// Write custom types forward declarations
	didHeader = false;
	const SKeyedVector<SString, sptr<IDLType> >& tb = getTypeBank();
	size_t tbCount = tb.CountItems();
	for (size_t i = 0; i < tbCount; i++) {
		const sptr<IDLType>& t = tb.ValueAt(i);
		uint32 code = t->GetCode();
		if (code == B_WILD_TYPE) {
			if (!didHeader) {
				stream << endl;
				stream << "// ============= Custom Types Forward Declarations ============== " << endl;
				stream << endl;
				didHeader = true;
			}
			stream << "class " << t->GetName() << ";" << endl;
		}
	}
	if (didHeader) {
		stream << endl;
	}
*/
	// Write class definitions
	stream << "/* ============= Interface Class Declarations =========================== */" << endl;
	stream << endl;
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
		SString noid=rec->ID();
		noid.RemoveFirst("I");
		if (rec->Declaration()==DCL) {
			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());
			rec->OutputComment(stream, false);
			SVector<SString> parents = rec->Parents();
			if (parents.CountItems() == 0) {
				stream << "class " << rec->ID() << " : virtual public Customizable" << endl;
			} 
			else {
				stream << "class " << rec->ID() << " : ";
				for (size_t i_parent = 0; i_parent < parents.CountItems(); i_parent++) {
					if (i_parent > 0) {
						stream << ", ";
					}
					stream << "public " << parents[i_parent];
				}
				stream << endl;
			}
			stream << "{" << endl;

			// Write Class body...
			uint32 typedefCount = rec->CountTypedefs();
			uint32 propertyCount = rec->CountProperties();
			uint32 methodCount = rec->CountMethods();
			uint32 eventCount = rec->CountEvents();
			uint32 constructCount = rec->CountConstructs();

			stream << "public:" << endl;
			stream << indent;
			stream << endl << endl;

			// print all typedefs
			if (typedefCount != 0) {
				stream << endl;
				stream << "/* ------- Typedefs --------------------- */" << endl;
			}
			for (uint32 i_typedef = 0; i_typedef < typedefCount; i_typedef++) {
				sptr<IDLNameType> def = rec->TypedefAt(i_typedef);
				stream << dedent;
				def->OutputComment(stream);
				stream << indent;
				stream << "typedef ";
				// get the base type for this typedef and convert that
				sptr<IDLType> baseType = FindType(def->m_type);
				SString cppType = TypeToCPPType(kInsideClassScope, baseType, false);
				if (baseType->GetCode() == B_VARIABLE_ARRAY_TYPE) {
					stream << "SVector<" << cppType;
					if (cppType.FindFirst('>') > 0) {
						// leave extra space when we are dealing with 
						// a template type
						stream << " ";
					}
					stream << ">";
				}
				else {
					stream << cppType;
				}
				stream << " " << def->m_id << ";" << endl;
			}

			// take care of any enums/structs we have
			// They are packaged as IDLMethods, with each member being a parameter
			if (constructCount > 0) {
				stream << endl;
				stream << "/* ------- enums/structs --------------------- */" << endl;
			}
			for (size_t i_enum = 0; i_enum < constructCount; i_enum++) {
				sptr<IDLConstruct> construct = rec->ConstructAt(i_enum);
				stream << dedent;
				construct->OutputComment(stream);	
				stream << indent;
				SString constructName = construct->ID();
				bool inStruct = (constructName.FindLast("struct") >= 0);
				stream << constructName << " {" << endl << indent;

				uint32 memberCount = construct->CountParams();
				for (uint32 i_member = 0; i_member < memberCount; i_member++) {
					sptr<IDLNameType> member = construct->ParamAt(i_member);
					// first write the comment (if it exists, it will end with newline)
					member->OutputComment(stream);
					// then write the actual member
					stream << member->m_id;
					// terminate the member/enumerator 
					if (inStruct == true) {
						stream << ";";
					}
					else if (i_member < memberCount-1) {
						stream << ",";
					}
					stream << endl;
				}
				construct->OutputTrailingComment(stream);
				stream << dedent << "};" << endl << endl;
			}
		
			if (propertyCount != 0) {
				stream << endl;
				stream << "/* ------- Properties --------------------- */" << endl;
			}
			for (uint32 i_prop = 0; i_prop < propertyCount; i_prop++) {
				sptr<IDLNameType> nt = rec->PropertyAt(i_prop);
				stream << endl;
				WritePropertyDeclarations(stream, nt, true);
			}
			
			if (methodCount != 0) {
				stream << endl;
				stream << "// ------- Methods ------------------------" << endl;
			}
			for (uint32 i_method = 0; i_method < methodCount; i_method++) {
				sptr<IDLMethod> method = rec->MethodAt(i_method);
				stream << endl;
				WriteMethodDeclaration(stream, method, true);
			}

			if (eventCount != 0) {
				stream << endl;
				stream << "// ------- Events ------------------------" << endl;
			}
	
			for (uint32_t i_event = 0; i_event < eventCount; i_event++) {
				sptr<IDLEvent> event = rec->EventAt(i_event);
				stream << endl;
				WriteEventDeclaration(stream, event);
			}

			/* ------- protected default ctor/dtor ------------------------- */
			/* ------- private copy constructor and assignment operator ------------------------- */
			stream << dedent;
			stream << endl << "protected:" << endl;
			stream << indent;
			SString className = LocalClassName(rec);
			stream << "\t\t" << PadString(SString(""), TYPE_TABS) << className << "();" << endl;
			stream << "virtual\t" << PadString(SString(""), TYPE_TABS) << "~" << className << "();" << endl;

			stream << dedent;
			stream << endl << "private:" << endl;
			stream << indent;
			/*stream << "// ------- copy/assignment protection ------------------" << endl;
			// SString className = rec->ID();
			stream << "\t\t" << PadString(SString(""), TYPE_TABS)
					<< className << "(const " << className << "& o);" << endl;
			SString classReference(className);
			classReference.Append("*");
			stream << "\t\t" << classReference << PadString(classReference, TYPE_TABS)
					<< "operator=(const " << className << "* o);" << endl;
			*/
			stream << dedent;
			stream << "};" << endl;
			stream << endl;
		}
	}

	// IPC proxy class
	stream << endl;
	stream << "// IPC proxy classes" << endl << endl;
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
		SString className = IPCProxyClassName(rec);
		if (rec->Declaration() != DCL)
			continue;
		stream << "class " << className << " : public " << LocalClassName(rec);
		stream << " { " << endl;
		stream << "public:" << endl;
		stream << indent;

		// constructors
		stream << PadString(SString(""), TOTAL_TABS - 1) << className
			<< "(const BMessenger& messenger, uint32 handle);" << endl;
		stream << PadString(SString(""), TOTAL_TABS - 1) << className
			<< "(const BMessenger& messenger, uint32 handle, team_id proxyTeam);"
			<< endl;
		// destructor
		stream << PadString(SString(""), TOTAL_TABS - 1) << "~" << className
			<< "();" << endl;

		/*
		uint32 propertyCount = rec->CountProperties();
		if (propertyCount != 0) {
			stream << endl;
			stream << "// ------- Properties ---------------------" << endl;
		}
		for (uint32 i_prop = 0; i_prop < propertyCount; i_prop++) {
			sptr<IDLNameType> nt = rec->PropertyAt(i_prop);
			stream << endl;
			WritePropertyDeclarations(stream, nt, false);
		}*/

		uint32 methodCount = rec->CountMethods();		
		if (methodCount != 0) {
			stream << endl;
			stream << "// ------- Methods ------------------------" << endl;
		}
		for (uint32 i_method = 0; i_method < methodCount; i_method++) {
			sptr<IDLMethod> method = rec->MethodAt(i_method);
			stream << endl;
			WriteMethodDeclaration(stream, method, false);
		}

		stream << dedent;
		stream << endl;
		stream << "private:" << endl;
		// variables
		stream << indent << indent << indent;
		stream << "BMessenger" << PadString(SString("BMessenger"), TYPE_TABS)
			<< "fRemoteMessenger;"<< endl;
		stream << "int32" << PadString(SString("int32"), TYPE_TABS)
			<< "fHandle;"<< endl;
		stream << "team_id" << PadString(SString("team_id"), TYPE_TABS)
			<< "fProxyTeam;"<< endl;
		stream << dedent << dedent;

		stream << dedent;
		stream << "};" << endl;
		stream << endl;
	}
	
	nsGen.CloseNamespace(stream);

	//bout << "// end comments: " << endComments << endl;
	if (endComments != NULL) {
		stream << endl;
		endComments->Output(stream, false);
	}

	stream << endl;
	stream << "#endif // " << headerGuard << endl;
	stream << endl;
	
	return true;
}


static const char*
PaladinTypeFor(const sptr<IDLType>& type)
{
	sptr<IDLType> baseType = FindType(type);
	uint32 code = baseType->GetCode();

	switch (code) {
		case B_BOOL_TYPE:
			return "B_BOOL_TYPE";

		case B_INT8_TYPE:
		case B_UINT8_TYPE:
			return "B_INT8_TYPE";

		case B_INT16_TYPE:
		case B_UINT16_TYPE:
			return "B_INT16_TYPE";

		case B_INT32_TYPE:
		case B_UINT32_TYPE:
			return "B_INT32_TYPE";

		case B_INT64_TYPE:
		case B_UINT64_TYPE:
			return "B_INT64_TYPE";
		
		case B_FLOAT_TYPE:
			return "B_FLOAT_TYPE";

		case B_DOUBLE_TYPE:
			return "B_DOUBLE_TYPE";
		
		case B_STRING_TYPE:
			return "B_STRING_TYPE";

		case B_CHAR_TYPE:
			return "B_CHAR_TYPE";
	}

	return "B_RAW_TYPE";
}


static void
ParameterAddToPArg(sptr<ITextOutput>& stream, sptr<IDLNameType>& nt,
	const char* outVar, const SString& varName, bool varIsPointer = false)
{
	SString type = TypeToCPPType(kInsideClassScope, nt->m_type, false);

	uint32 code = nt->m_type->GetCode();
	sptr<IDLType> bankType = FindType(nt->m_type);
	if (bankType != NULL)
		code = bankType->GetCode();

	if (type == "void")
		return;

	if (nt->m_type->GetName() == "sptr") {
		stream << outVar << "->AddPointer(\"" << nt->m_id << "\", ";
		if (nt->m_type->HasAttribute(kWeak))
			stream << "&";
		stream << varName;
	} else if (type == "BString") {
		stream << outVar << "->AddString(\"" << nt->m_id << "\", "	<< varName;
	} else if (type == "status_t") {
		stream << outVar << "->AddInt32(\"" << nt->m_id << "\", " << varName;
	} else if (code == B_WILD_TYPE) {
		SString varNameMessage = varName;
		varNameMessage.Append("Message");
		stream << "BMessage " << varNameMessage << ";" << endl;
		stream << type << "ToMessage(";
		if (varIsPointer == false)
			stream << "&";
		stream << varName << ", &" << varNameMessage << ");" << endl;
		stream << outVar << "->AddMessage(\"" << nt->m_id << "\", &"
		<< varNameMessage;
	} else {
		stream << "add_parg_" << type << "(" << outVar << ", \"" << nt->m_id
			<< "\", ";
		if (varIsPointer)
			stream << "*";
		stream << varName;
	}
	stream << ")";
}


static void
ParameterFromPArg(sptr<ITextOutput>& stream, sptr<IDLNameType>& nt,
	const char* inVar, const char* fieldName, SString& varName,
		bool varIsPointer = false)
{
	SString type = TypeToCPPType(kInsideClassScope, nt->m_type, false);

	uint32 code = nt->m_type->GetCode();
	sptr<IDLType> bankType = FindType(nt->m_type);
	if (bankType != NULL)
		code = bankType->GetCode();

	if (nt->m_type->GetName() == "sptr") {
		stream << "status = " << inVar << "->FindPointer(" << fieldName
			<< ", (void**)&" << varName << ");" << endl;
	} else if (type == "BString") {
		stream << "status = " << inVar << "->FindString(" << fieldName << ", ";
		if (varIsPointer == false)
			stream << "&";
		stream << varName << ");" << endl;
	} else if (type == "status_t") {
		stream << "status = find_parg_int32(" << inVar << ", " << fieldName
			<< ", ";
		if (varIsPointer == false)
			stream << "&";
		stream << varName << ");" << endl;
	} else if (code == B_WILD_TYPE) {
		SString varNameMessage = varName;
		varNameMessage.Append("Message");
		stream << "BMessage " << varNameMessage << ";" << endl;
		stream << "status = " << inVar << "->FindMessage(" << fieldName << ", &"
			<< varNameMessage << ");" << endl;
		stream << "if (status == B_OK) {" << endl;
		stream << indent;
		stream  << type << "FromMessage(";
		if (varIsPointer == false)
			stream << "&";
		stream << varName << ", &" << varNameMessage << ");" << endl;
		stream << dedent << "}" << endl;
	} else {
		stream << "status = find_parg_" << type << "(" << inVar << ", "
			<< fieldName << ", ";
		if (varIsPointer == false)
			stream << "&";
		stream << varName << ");" << endl;
	}
}


static void
WriteCallbackMethod(sptr<ITextOutput>& stream, SString& className,
	sptr<IDLMethod>& method)
{
	SString callbackName("_");
	callbackName += className;
	callbackName += method->ID();

	stream << "static status_t" << endl;
	stream << callbackName
		<< "(void* pObject, PArgs *in, PArgs *out, void*)"
		<< endl;
	stream << "{" << endl << indent;

	stream << "if (!pObject || !in || !out)" << endl << indent
		<< "return B_ERROR;" << dedent << endl;

	stream << className << "* that = dynamic_cast<" << className
		<< "*>((BObject*)pObject);" << endl;
	stream << "if (!that)" << endl << indent
		<< "return B_BAD_TYPE;" << endl << dedent;

	int paramCount = method->CountParams();
	int32 inParamCount = 0;
	for (int32_t i_param = 0; i_param < paramCount; i_param++) {
		sptr<IDLNameType> nt = method->ParamAt(i_param);
		uint32_t direction = nt->m_type->GetDirection();
		if (direction != kOut)
			inParamCount++;
	}
	if (inParamCount > 0) {
		stream << "BString fieldName; type_code fieldType;" << endl;
		stream << "int32 callIndex; int32 fieldIndex;" << endl;
		stream << "status_t status = B_ERROR;" << endl;
	}
	stream << endl;

	SString argumentString;
	SVector<sptr<IDLNameType> > returnParam;
	SVector<SString> returnParamVar;
	int32 inParamIndex = 0;
	for (int32_t i_param = 0; i_param < paramCount; i_param++) {
		sptr<IDLNameType> nt = method->ParamAt(i_param);
		
		SString type = TypeToCPPType(kInsideClassScope, nt->m_type, false);

		SString varName("var");
		varName << i_param + 1;
		stream << type << " " << varName << ";" << endl;

		uint32_t direction = nt->m_type->GetDirection();
		if (direction != kOut) {
			stream << "if (in->FindOrderInfo(" << inParamIndex
				<< ", fieldName, fieldType, callIndex, fieldIndex) != B_OK)"
				<< endl;
			stream << indent << "return B_ERROR;" << dedent << endl;

			SString fetchVarName = varName;
			if (nt->m_type->GetName() == "sptr") {
				fetchVarName += "Pointer";
				if (nt->m_type->HasAttribute(kWeak))
					stream << type << "* " << fetchVarName << ";" << endl;
				else {
					stream << nt->m_type->GetIface() << "* " << fetchVarName
						<< ";" << endl;
				}
			}

			ParameterFromPArg(stream, nt, "in", "fieldName", fetchVarName);
			stream << "if (status != B_OK)" << endl;
			stream << indent << "return status;" << endl << dedent;

			if (nt->m_type->GetName() == "sptr") {
				if (nt->m_type->HasAttribute(kWeak))
					stream << varName << " = *" << fetchVarName << ";" << endl;
				else
					stream << varName << " = " << fetchVarName << ";" << endl;
			}
			stream << endl;

			inParamIndex++;
		}

		if (i_param != 0)
			argumentString += ", ";
		if ((direction == kOut || direction == kInOut)
			&& nt->m_type->GetName() != "sptr" && type != "BString")
			argumentString += "&";
		argumentString += varName;

		if ((direction == kOut) || (direction == kInOut)) {
			returnParam.AddItem(nt);
			returnParamVar.AddItem(varName);
		}
	}

	sptr<IDLCommentBlock> dummyComment;
	sptr<IDLNameType> returnType = new IDLNameType(SString("returnValue"),
		method->ReturnType(), dummyComment);
	sptr<IDLType> ntType = method->ReturnType();
	SString returnTypeString = TypeToCPPType(kInsideClassScope, ntType, false);
	if (returnTypeString != "void") {
		stream << returnTypeString << " returnValue = ";
		returnParam.AddItem(returnType);
		returnParamVar.AddItem(SString("returnValue"));
	}
	stream << "that->" << method->ID() << "(" << argumentString << ");" << endl;
	stream << endl;

	stream << "// output" << endl;
	stream << "{" << endl;
	for (uint32 i = 0; i < returnParam.CountItems(); i++) {
		sptr<IDLNameType> item = returnParam.ItemAt(i);
		ParameterAddToPArg(stream, item, "out", returnParamVar[i]);
		stream << ";" << endl;
	}
	stream << "}" << endl;

	stream << endl << "return B_OK;" << endl;
	stream << dedent << "}" << endl;
	stream << endl << endl;
}


static void
WriteIPCMethod(sptr<ITextOutput>& stream, SString& className,
	sptr<IDLMethod> method)
{
	sptr<IDLType> returnType = method->ReturnType();
	SString type = TypeToCPPType(kInsideClassScope, returnType, false);
	stream << type << endl;
	stream << className << "::" << method->ID() << "(";
	
	int32_t paramCount = method->CountParams();
	for (int32_t i_param = 0; i_param < paramCount; i_param++) {
		sptr<IDLNameType> nt = method->ParamAt(i_param);
		uint32_t direction = nt->m_type->GetDirection();
		//bool isOptional = nt->m_type->HasAttribute(kOptional);
		if ((direction == kInOut) || (direction == kOut)) {	
			type = TypeToCPPType(kInsideClassScope, nt->m_type, false);
			// do we want to distinguish array types here?
			// if so, we would need to lookup type and check for B_VARIABLE_ARRAY_TYPE
			//sptr<IDLType> bankType = FindType(nt->m_type);
			stream << type;
			if (type == "BString")
				stream << "&";
			else
				stream << "*";
			stream << " " << nt->m_id;
		}
		else { 
			SString type = TypeToCPPType(kInsideClassScope, nt->m_type, true);
			if (type == "BString")
				stream << "const " << type << "&";
			else
				stream << type;
			stream << " " << nt->m_id;
		}
		
		// end the parameter with comma (if not the last)
		if (i_param < paramCount-1) {
			stream << ", ";
		}
	}

	stream << ")" << endl;
	stream << "{" << endl << indent;

	stream << "PArgs in;" << endl;
	for (int32_t i_param = 0; i_param < paramCount; i_param++) {
		sptr<IDLNameType> nt = method->ParamAt(i_param);
		uint32_t direction = nt->m_type->GetDirection();
		if (direction == kOut)
			continue;
		bool isPointer = (direction != kOut && direction != kInOut) ? false
			: true;
		ParameterAddToPArg(stream, nt, "(&in)", nt->m_id, isPointer);
		stream << ";" << endl;
	}
	stream << "BMessage outMessage(kMsgRunMethod);" << endl;
	stream << "thread_info threadInfo;" << endl;
	stream << "if (get_thread_info(find_thread(NULL), &threadInfo) == B_OK)" << endl;
	stream << indent << "outMessage.AddInt32(\"priority\", threadInfo.priority);"
		<< dedent << endl;
	stream << "outMessage.AddInt32(\"handle\", fHandle);" << endl;
	stream << "outMessage.AddString(\"method\", \"" << method->ID() << "\");" << endl;
	stream << "BMessage argMessage = in.GetBackend();" << endl;
	stream << "outMessage.AddMessage(\"args\", &argMessage);" << endl;
	stream << "BMessage reply;" << endl;
	stream << "fRemoteMessenger.SendMessage(&outMessage, &reply);" << endl;

	stream << endl << "{" << endl;
	stream << "PArgs out;" << endl;
	stream << "out.SetBackend(reply);" << endl;

	bool statusWrote = false;
	for (int32_t i_param = 0; i_param < paramCount; i_param++) {
		sptr<IDLNameType> nt = method->ParamAt(i_param);
		uint32_t direction = nt->m_type->GetDirection();
		if (direction != kOut && direction != kInOut)
			continue;
		if (!statusWrote) {
			stream << "status_t status = B_ERROR;" << endl;
			statusWrote = true;
		}
	
		SString fieldName("\"");
		fieldName << nt->m_id << "\"";
		SString type = TypeToCPPType(kInsideClassScope, nt->m_type, true);
		bool isPointer = true;
		if (type == "BString")
			isPointer = false;
		ParameterFromPArg(stream, nt, "(&out)", fieldName, nt->m_id, isPointer);
	}

	sptr<IDLCommentBlock> dummyComment;
	sptr<IDLNameType> returnNameType = new IDLNameType(SString("returnValue"),
		method->ReturnType(), dummyComment);
	sptr<IDLType> ntType = method->ReturnType();
	SString returnTypeString = TypeToCPPType(kInsideClassScope, ntType, false);
	if (returnTypeString != "void") {
		if (!statusWrote) {
			stream << "status_t status = B_ERROR;" << endl;
			statusWrote = true;
		}
		SString varName("returnValue");
		stream << returnTypeString << " " << varName << ";" << endl;
		ParameterFromPArg(stream, returnNameType, "(&out)", "\"returnValue\"",
			varName, false);
		stream << "return returnValue;" << endl;
	}
	stream << "}" << endl;

	stream << endl;
	stream << dedent << "}" << endl;
}


static void
WriteEventBody(sptr<ITextOutput>& stream, SString& className,
	sptr<IDLEvent> event)
{
	stream << "void" << endl;
	stream << className << "::Send" << event->ID() << "(";
	int32_t paramCount = event->CountParams();

	for (int32_t i_param = 0; i_param < paramCount; i_param++) {
		sptr<IDLNameType> nt = event->ParamAt(i_param);
		if (nt->HasComment()) {
			stream << endl;
			nt->OutputComment(stream);
		}
		SString type = TypeToCPPType(kInsideClassScope, nt->m_type, true);
		if (type == "BString")
			stream << "const " << type << "&";
		else
			stream << type;
		stream << " " << nt->m_id;
		if (i_param < paramCount-1) {
			stream << ", ";
		}
	}
	stream << ")" << endl;
	stream << "{" << endl << indent;

	stream << "PArgs in;" << endl;
	stream << "PArgs out;" << endl;
	bool hasRef = false;
	int32 weakIndex = 0;
	for (int32_t i_param = 0; i_param < paramCount; i_param++) {
		sptr<IDLNameType> nt = event->ParamAt(i_param);
		SString varName = nt->m_id;

		if (nt->m_type->GetName() == "sptr") {
			if (!hasRef) {
				stream << "BReference<async_refs> refs(new async_refs, true);"
					<< endl;
				hasRef = true;	
			}
			if (nt->m_type->HasAttribute(kWeak))
				stream << "refs->weakRefs.push_back(";
			else
				stream << "refs->strongRefs.push_back(";
			stream << nt->m_id << ");" << endl;

			// give a direct pointer to weak ref
			if (nt->m_type->HasAttribute(kWeak)) {
				varName = "refs->weakRefs[";
				varName << weakIndex << "]";
				weakIndex++;
			}
		}

		ParameterAddToPArg(stream, nt, "(&in)", varName);
		stream << ";" << endl;
	}
	stream << endl;

	stream << "FireEventAsync(\"" << event->ID() << "\", in, out";
	if (hasRef)
		stream << ", refs";
	stream << ");" << endl;

	stream << dedent << "}" << endl;
}


bool
CustomizableBackend::_WriteCPP(sptr<ITextOutput> stream, SVector<InterfaceRec *> &recs,
	const SString & filename, const SString & lHeader)
{
	SString printablefn=filename;
	printablefn.Append(".cpp");
	printablefn.RemoveFirst(".\\");

	stream << "/*========================================================== */ " << endl;
	stream << "// "<< printablefn << " is automatically generated by PIDGEN - DO NOT MODIFY" << endl;
	stream << "/*========================================================== */ " << endl << endl;

	stream << endl;

	stream << "#include " << '\"' << lHeader << '\"' << endl;
	stream << endl;
	stream << "#include <InterfaceDefs.h>" << endl << endl;
	stream << "#include <PObject.h>" << endl << endl;

	NamespaceGenerator nsGen;
	size_t recordCount = recs.CountItems();
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
	
		SString className = LocalClassName(rec);	

		if (rec->Declaration()==DCL) {
			nsGen.EnterNamespace(stream, rec->Namespace(), rec->CppNamespace());

			// ------ Callback Method Functions
			int32_t methodCount = rec->CountMethods();
			for (int32_t i_method = 0; i_method < methodCount; i_method++) {
				sptr<IDLMethod> method = rec->MethodAt(i_method);
				WriteCallbackMethod(stream, className, method);
			}


			// ------ Class Members
			stream << "// ------ Class Members ----------------------" << endl;
			stream << endl;

			// constructor
			stream << className << "::" << className << "()" << endl;
			stream << "{" << endl << indent;

			stream << "AddInterface(\"" << rec->ID() << "\");" << endl;

			stream << "PMethodInterface pmi;" << endl;
			
			for (int32_t i_method = 0; i_method < methodCount; i_method++) {
				sptr<IDLMethod> method = rec->MethodAt(i_method);
				SString callbackName("_");
				callbackName += className;
				callbackName += method->ID();

				stream << "pmi.MakeEmpty();" << endl;
				int paramCount = method->CountParams();
				for (int32_t i_param = 0; i_param < paramCount; i_param++) {
					sptr<IDLNameType> nt = method->ParamAt(i_param);
					if (nt->m_type->GetDirection() == kOut)
						continue;	
					stream << "pmi.AddArg(\"" << nt->m_id << "\", "
						<< PaladinTypeFor(nt->m_type) << ", \"\");" << endl;
				}
				stream << "AddMethod(new PMethod(\"" << method->ID()
					<< "\", " << callbackName << ", &pmi));" << endl << endl;
			}
			
			uint32 eventCount = rec->CountEvents();
			for (uint32_t i_event = 0; i_event < eventCount; i_event++) {
				sptr<IDLEvent> event = rec->EventAt(i_event);
				stream << "pmi.MakeEmpty();" << endl;
				uint32_t paramCount = event->CountParams();
				for (uint32_t i_param = 0; i_param < paramCount; i_param++) {
					sptr<IDLNameType> nt = event->ParamAt(i_param);
					if (nt->m_type->GetDirection() == kOut)
						continue;	
					stream << "pmi.AddArg(\"" << nt->m_id << "\", "
						<< PaladinTypeFor(nt->m_type) << ", \"\");" << endl;
				}

				stream << "AddEvent(\"" << event->m_id << "\", &pmi);" << endl << endl;
			}

			stream << dedent << "}" << endl;
			stream << endl;
			stream << endl;

			// ------- Methods

			// Currently our only class member is an empty destructor.
			// But this is needed for the vtable copy needed for RVDS, and C++ library support
			stream << rec->ID() << "::~" << rec->ID() << "()" << endl;
			stream << "{" << endl;
			stream << "}" << endl << endl;

			stream << endl;

			// ------- Events

			
			for (uint32_t i_event = 0; i_event < eventCount; i_event++) {
				sptr<IDLEvent> event = rec->EventAt(i_event);
				
				WriteEventBody(stream, className, event);
			}

			stream << endl;
			stream << endl;
		}

	}

	// IPC proxy classes
	stream << "// IPC proxy classes" << endl;
	for (size_t i_record = 0; i_record < recordCount; i_record++) {
		InterfaceRec* rec = recs[i_record];
	
		SString className = IPCProxyClassName(rec);	

		if (rec->Declaration() != DCL) 
			continue;

		// ------ Class Members
		// constructors
		stream << className << "::" << className
			<< "(const BMessenger& messenger, uint32 handle)" << endl;
		stream << indent << ":" << endl;
		stream << "fRemoteMessenger(messenger)," << endl;
		stream << "fHandle(handle)," << endl;
		stream << "fProxyTeam(-1)" << endl;
		stream << dedent;
		stream << "{" << endl << indent;
		stream << "thread_info threadInfo;" << endl;
		stream << "if (get_thread_info(find_thread(NULL), &threadInfo) == B_OK)"
			<< endl;
		stream << indent << "fProxyTeam = threadInfo.team;" << endl << dedent;
		stream << dedent << "}" << endl << endl << endl;

		stream << className << "::" << className
			<< "(const BMessenger& messenger, uint32 handle, team_id proxyTeam)"
			<< endl;
		stream << indent << ":" << endl;
		stream << "fRemoteMessenger(messenger)," << endl;
		stream << "fHandle(handle)," << endl;
		stream << "fProxyTeam(proxyTeam)" << endl;
		stream << dedent;
		stream << "{" << endl;
		stream << "}" << endl << endl << endl;

		// destructor
		stream << className << "::~" << className << "()" << endl;
		stream << dedent;
		stream << "{" << endl << indent;
		stream << "BMessage message(kMsgReleaseReference);" << endl;
		stream << "message.AddInt32(\"team\", fProxyTeam);" << endl;
		stream << "message.AddInt32(\"handle\", fHandle);" << endl;
		stream << "fRemoteMessenger.SendMessage(&message);" << endl;
		stream << dedent << "}" << endl << endl << endl;

		stream << "// Class Members (" << className << ")" << endl;
		stream << endl << endl;

		// ------- Methods
		int32_t methodCount = rec->CountMethods();
		for (int32_t i_method = 0; i_method < methodCount; i_method++) {
			sptr<IDLMethod> method = rec->MethodAt(i_method);
			WriteIPCMethod(stream, className, method);
			stream << endl << endl;
		}
	}

	nsGen.CloseNamespace(stream);

	return false;
}
