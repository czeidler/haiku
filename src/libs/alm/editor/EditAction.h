/*
 * Copyright 2012, Clemens Zeidler <haiku@clemens-zeidler.de>
 * Distributed under the terms of the MIT License.
 */
#ifndef	EDIT_ACTION_H
#define	EDIT_ACTION_H


#include <Application.h>
#include <Cursor.h>

#include "AreaRemoval.h"
#include "LayoutArchive.h"
#include "LayoutEditView.h"


namespace BALM {


const int32 kTabWidth = 1;
const int32 kTolerance = 7;

const rgb_color kSuggestionColor = {0, 115, 200};
const rgb_color kSelectedColor = {100, 20, 20}; // selected pen
const rgb_color kDestinationColor = {45, 125, 60}; // destination pen
const rgb_color kMarkedTabColor = {0, 100, 100};

const int8 kDestinationPen = 2;


// These cursors are taken from icon o matic.

const uint8 kMoveCursor[] = { 16, 1, 8, 8,
	0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x08, 0x10,
	0x1e, 0x78, 0x2a, 0x54, 0x4e, 0x72, 0x80, 0x01,
	0x80, 0x01, 0x4e, 0x72, 0x2a, 0x54, 0x1e, 0x78,
	0x08, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x80,

	0x01, 0x80, 0x03, 0xc0, 0x07, 0xe0, 0x0f, 0xf0,
	0x1f, 0xf8, 0x3b, 0xdc, 0x7f, 0xfe, 0xff, 0xff,
	0xff, 0xff, 0x7f, 0xfe, 0x3b, 0xdc, 0x1f, 0xf8,
	0x0f, 0xf0, 0x07, 0xe0, 0x03, 0xc0, 0x01, 0x80 };

const uint8 kLeftRightCursor[] = { 16, 1, 8, 8,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x28, 0x14, 0x4f, 0xf2, 0x80, 0x01,
	0x80, 0x01, 0x4f, 0xf2, 0x28, 0x14, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x38, 0x1c, 0x7f, 0xfe, 0xff, 0xff,
	0xff, 0xff, 0x7f, 0xfe, 0x38, 0x1c, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

const uint8 kUpDownCursor[] = { 16, 1, 8, 8,
	0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x08, 0x10,
	0x0e, 0x70, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40,
	0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x0e, 0x70,
	0x08, 0x10, 0x04, 0x20, 0x02, 0x40, 0x01, 0x80,

	0x01, 0x80, 0x03, 0xc0, 0x07, 0xe0, 0x0f, 0xf0,
	0x0f, 0xf0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0,
	0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x0f, 0xf0,
	0x0f, 0xf0, 0x07, 0xe0, 0x03, 0xc0, 0x01, 0x80 };

const uint8 kLeftTopRightBottomCursor[] = { 16, 1, 8, 8,
	0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x21, 0x00,
	0x22, 0x00, 0x21, 0x00, 0x28, 0x80, 0x34, 0x40,
	0x02, 0x2c, 0x01, 0x14, 0x00, 0x84, 0x00, 0x44,
	0x00, 0x84, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x3f, 0x00,
	0x3e, 0x00, 0x3f, 0x00, 0x3f, 0x80, 0x37, 0xc0,
	0x03, 0xec, 0x01, 0xfc, 0x00, 0xfc, 0x00, 0x7c,
	0x00, 0xfc, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00 };

const uint8 kLeftBottomRightTopCursor[] = { 16, 1, 8, 8,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x84,
	0x00, 0x44, 0x00, 0x84, 0x01, 0x14, 0x02, 0x2c,
	0x34, 0x40, 0x28, 0x80, 0x21, 0x00, 0x22, 0x00,
	0x21, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0xfc,
	0x00, 0x7c, 0x00, 0xfc, 0x01, 0xfc, 0x03, 0xec,
	0x37, 0xc0, 0x3f, 0x80, 0x3f, 0x00, 0x3e, 0x00,
	0x3f, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00 };

const uint8 kUpArrowCursor[] = { 16, 1, 8, 8,
	0x03, 0xc0, 0x06, 0x60, 0x0c, 0x30, 0x18, 0x18,
	0x30, 0x0c, 0x20, 0x04, 0x3c, 0x3c, 0x04, 0x20,
	0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20,
	0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20,

	0x01, 0x80, 0x03, 0xc0, 0x07, 0xe0, 0x0f, 0xf0,
	0x1f, 0xf8, 0x3f, 0xfc, 0x3f, 0xfc, 0x07, 0xe0,
	0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0,
	0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0 };

const uint8 kDownArrowCursor[] = { 16, 1, 8, 8,
	0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20,
	0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20,
	0x04, 0x20, 0x3c, 0x3c, 0x20, 0x04, 0x30, 0x0c,
	0x18, 0x18, 0x0c, 0x30, 0x06, 0x60, 0x03, 0xc0,

	0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0,
	0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0, 0x07, 0xe0,
	0x07, 0xe0, 0x3f, 0xfc, 0x3f, 0xfc, 0x1f, 0xf8,
	0x0f, 0xf0, 0x07, 0xe0, 0x03, 0xc0, 0x01, 0x80 };

const uint8 kLeftArrowCursor[] = { 16, 1, 8, 8,
	0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x1a, 0x00,
	0x32, 0x00, 0x63, 0xff, 0xc0, 0x00, 0x80, 0x00,
	0x80, 0x00, 0xc0, 0x00, 0x63, 0xff, 0x32, 0x00,
	0x1a, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x0e, 0x00,
	0x1e, 0x00, 0x3f, 0xff, 0x7f, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x7f, 0xff, 0x3f, 0xff, 0x1e, 0x00,
	0x0e, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00 };

const uint8 kRightArrowCursor[] = { 16, 1, 8, 8,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x58,
	0x00, 0x4c, 0xff, 0xc6, 0x00, 0x03, 0x00, 0x01,
	0x00, 0x01, 0x00, 0x03, 0xff, 0xc6, 0x00, 0x4c,
	0x00, 0x58, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x70,
	0x00, 0x78, 0xff, 0xfc, 0xff, 0xfe, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xfe, 0xff, 0xfc, 0x00, 0x78,
	0x00, 0x70, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00 };

// These cursors are temporarily taken from CursorData.cpp in src/servers/app.
const uint8 default_resize_ew_data[] = {
	0x10, 0x01, 0x07, 0x07, 0x00, 0x00, 0x01, 0x00,
	0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x11, 0x10,
	0x31, 0x18, 0x71, 0x1C, 0x71, 0x1C,	0x31, 0x18,
	0x11, 0x10, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x80,
	0x03, 0x80, 0x0B, 0xA0,	0x1B, 0xB0, 0x3B, 0xB8,
	0x7B, 0xBC, 0xFB, 0xBE, 0xFB, 0xBE, 0x7B, 0xBC,
	0x3B, 0xB8, 0x1B, 0xB0, 0x0B, 0xA0, 0x03, 0x80,
	0x03, 0x80,	0x01, 0x00
};
const uint8 default_resize_ns_data[] = {
	0x10, 0x01, 0x07, 0x07, 0x00, 0x00, 0x01, 0x80,
	0x03, 0xC0, 0x07, 0xE0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x07, 0xE0, 0x03, 0xC0, 0x01, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x03, 0xC0,
	0x07, 0xE0, 0x0F, 0xF0,	0x1F, 0xF8, 0x00, 0x00,
	0x7F, 0xFE, 0xFF, 0xFF, 0x7F, 0xFE, 0x00, 0x00,
	0x1F, 0xF8, 0x0F, 0xF0, 0x07, 0xE0, 0x03, 0xC0,
	0x01, 0x80,	0x00, 0x00
};


static void set_cursor(const BCursor* cursor)
{
	be_app->SetCursor(cursor);
}


static void set_cursor(const uint8* cursorData)
{
	BCursor cursor(cursorData);
	set_cursor(&cursor);
}


bool fuzzy_equal(float x1, float x2);


class ActionEditHelper {
public:


static BRect compose_frame(BPoint leftTop, BSize prefSize, BALMLayout* layout)
{
	float xSpacing, ySpacing;
	layout->GetSpacing(&xSpacing, &ySpacing);
	// check if the area is complete
	BRect frame;
	frame.left = leftTop.x;
	frame.right = frame.left + (prefSize.width + xSpacing);
	frame.top = leftTop.y;
	frame.bottom = frame.top + (prefSize.height + ySpacing);

	return frame;
}


static BRect validate_frame(area_ref& ref, BSize prefSize, BALMLayout* layout)
{
	float xSpacing, ySpacing;
	layout->GetSpacing(&xSpacing, &ySpacing);
	// check if the area is complete
	BRect frame = ref.Frame();
	if (prefSize.width >= 0) {
		if (ref.left == NULL)
			frame.left = frame.right - (prefSize.width + xSpacing);
		else if (ref.right == NULL)
			frame.right = frame.left + (prefSize.width + xSpacing);
	}
	if (prefSize.height >= 0) {
		if (ref.top == NULL)
			frame.top = frame.bottom - (prefSize.height + ySpacing);
		else if (ref.bottom == NULL)
			frame.bottom = frame.top + (prefSize.height + ySpacing);
	}
	return frame;
}


static void get_target_area(area_info target, area_ref& ref, BALMLayout* layout,
	BSize prefSize, area_info maxArea, BPoint freePosition)
{
	ref = target.to_ref(layout);

	float xSpacing, ySpacing;
	layout->GetSpacing(&xSpacing, &ySpacing);

	if (ref.left == NULL) {
		ref.left = layout->AddXTab();
		if (ref.right != NULL) {
			ref.left->SetValue(
				ref.right->Value() - (prefSize.width + xSpacing));
		}
	}
	if (ref.right == NULL) {
		ref.right = layout->AddXTab();
		if (ref.left != NULL) {
			ref.right->SetValue(
				ref.left->Value() + (prefSize.width + xSpacing));
		}
	}
	if (ref.top == NULL) {
		ref.top = layout->AddYTab();
		if (ref.bottom != NULL) {
			ref.top->SetValue(
				ref.bottom->Value() - (prefSize.height + ySpacing));
		}
	}
	if (ref.bottom == NULL) {
		ref.bottom = layout->AddYTab();
		if (ref.top != NULL) {
			ref.bottom->SetValue(
				ref.top->Value() + (prefSize.height + ySpacing));
		}
	}

	const double kPenalty = 5;
	// free positioning at freePosition
	if (target.left == -1 && target.right == -1) {
		Constraint* constraint = layout->AddConstraint(1, ref.left,
			LinearProgramming::kEQ, freePosition.x, kPenalty, kPenalty);
		constraint->SetLabel("_EditHelper");
	}
	if (target.top == -1 && target.bottom == -1) {
		Constraint* constraint = layout->AddConstraint(1, ref.top,
			LinearProgramming::kEQ, freePosition.y, kPenalty, kPenalty);
		constraint->SetLabel("_EditHelper");
	}
}


};


class InsertionIntoEmptyArea {
public:
								InsertionIntoEmptyArea();

			void				SetTo(LayoutEditView* view,
									BSize prefSize, BSize minSize);

			void				Reset();
			bool				HasArea();

			bool				FindOptimalArea(BPoint point, BRect dragFrame,
									Area* movedArea = NULL);
			void				Draw();

			area_ref			CreateTargetArea();

			BRect				TargetFrame();

			bool				FindOptimalAreaFor(const BPoint& point,
									BRect dragFrame, BSize target,
									BSize minSize, area_ref& ref,
									area_ref& maximalArea, Area* movedArea);

			void				MaximizeEmptyArea(area_ref& ref, BRect target,
									BRect ignore);
private:
			LayoutEditView*		fView;
			BSize				fPreferredSize;
			BSize				fMinSize;

			BALM::area_info		fEmptyArea;
			BALM::area_info		fAvailableArea;
			BPoint				fFreePosition;
};


class BALMLayout;

class EditAction {
public:
								EditAction(BALMLayout* layout,
									BMessage* prevLayout)
									:
									fALMLayout(layout),
									fPrevLayout(prevLayout)
								{
								}
	virtual						~EditAction() {}
	virtual bool				Perform() = 0;
	virtual bool Undo()
	{
		LayoutArchive(fALMLayout).RestoreLayout(fPrevLayout, false);
		return true;
	}

	virtual	const char*			Name() { return ""; }

protected:
			BALMLayout*			fALMLayout;
			BMessage*			fPrevLayout;
};


class
LayoutEditView::State {
public:
	State(LayoutEditView* view)
		:
		fView(view)
	{
	}

	virtual	~State()
	{
		set_cursor(B_CURSOR_SYSTEM_DEFAULT);
	}

	virtual void EnterState() {}
	virtual bool MouseDown(BPoint point) { return true; }
	virtual bool MouseUp(BPoint point) { return true; }
	virtual bool MouseMoved(BPoint point, uint32 transit,
		const BMessage* message)
		 { return false; }

	virtual void Draw(BRect updateRect) {}

protected:
			LayoutEditView*		fView;
};


class
LayoutEditView::MouseOverState : public State {
public:
	MouseOverState(LayoutEditView* view)
		:
		State(view)
	{
	}


	virtual bool MouseMoved(BPoint point, uint32 transit,
		const BMessage* message)
	{
		Area* area = fView->FindArea(point);

		if (area) {
			XTab* xTab = fView->GetAreaXTabNearPoint(area, point, kTolerance);
			YTab* yTab = fView->GetAreaYTabNearPoint(area, point, kTolerance);

			if (fView->fSelectedArea != area) {
#if GROUP_TAB_RESIZE
				if (xTab != NULL)
					set_cursor(default_resize_ew_data);
				else if (yTab != NULL) 
					set_cursor(default_resize_ns_data);
				else
					set_cursor(kMoveCursor);
#else
					set_cursor(kMoveCursor);
#endif
			} else {
				if (xTab != NULL && yTab != NULL) {
					bool nwse = (area->Top() == yTab && area->Left() == xTab)
						|| (area->Bottom() == yTab && area->Right() == xTab);
					bool nesw = (area->Top() == yTab && area->Right() == xTab)
						|| (area->Bottom() == yTab && area->Left() == xTab);
					if (nwse)
						set_cursor(kLeftTopRightBottomCursor);
					else if (nesw)
						set_cursor(kLeftBottomRightTopCursor);
				} else if (xTab != NULL)
					set_cursor(kLeftRightCursor);
				else if (yTab != NULL) 
					set_cursor(kUpDownCursor);
				else
					set_cursor(kMoveCursor);
			}
		} else
			set_cursor(B_CURSOR_SYSTEM_DEFAULT);
		return true;
	}

};


}	// namespace BALM


#endif	// EDIT_ACTION_H
